### 数据的存储

1. 正负数的储存：

   ~~~ 
   源码：最高位为符号位，正数为0，负数为1
   反码：符号位不变，其他位按二进制按位取反
   补码：反码+1得到补码
   
   正数：以源码在内存中存贮
   例：10
   0000 0000 0000 0000 0000 0000 0000 1010 源码（储存形式）
   负数：以补码的形式在内存中存贮
   例子：-10
   1000 0000 0000 0000 0000 0000 0000 1010 源码
   1111 1111 1111 1111 1111 1111 1111 0101 反码
   1111 1111 1111 1111 1111 1111 1111 0110 补码（储存形式）
   ~~~

2. 大小端模式：

   ~~~ 
   小端存贮，高位存高位，计算机从左到右，地址依次增大
   例：10
   0000 0000 0000 0000 0000 0000 0000 1010 二进制储存形式
   00 00 00 0a 十六进制
   0a 00 00 00 内存中
   例：257
   0000 0000 0000 0000 0000 0001 0000 0001 二进制储存形式
   00 00 01 01 十六进制
   01 01 00 00 内存中
   例子：-10
   1111 1111 1111 1111 1111 1111 1111 0110 二进制储存形式
   ff ff ff f6 十六进制
   f6 ff ff ff 内存中
   ~~~

3. 浮点型存贮：

   ~~~ 
   0	0000 0000    0000 0000 0000 0000 0000 000 	     
   float:(-1)^S * M*2 ^ E
   
   S(1bit)：表示符号	
   E(8bit)：表示指数位,对于指数E，在内存中为应无符号整型，但是实际上浮点数的E会出现负数（浮点数很小时），所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。
   M(23bit): 转化为科学计数法后，都可成为1.xxx的形式，故为精度更加准确，舍弃(1.)只储存xxx
   
   例：5.5
   101.1 二进制
   科学计数法：(-1)^0 * 1.011 * 2^2
   
   S:0->0
   E:2->2+127->129->1000 0001
   M:011->011 0000 0000 0000 0000 0000
   0 1000 0001 011 0000 0000 0000 0000 0000
   0100 0000 1011 0000 0000 0000 0000 0000 二进制
   40 b0 00 00 十六进制
   00 00 b0 40 内存中
   注意：对于E中全为0的数，取出时为说明它极小，E做运算时指数部分为-126，M不+1而为0.xxx
   	 对于E中全为1的数，就表示正负无穷大
   	 对于既不全为0又不全为1的数，根据规定逆推即可
   double：表示的范围增大，规则同float
   S（1bit） E（11bit） M（52bit）
   ~~~

4. 编码方式：

   ~~~ python
   # 0. 记事本的默认编码是ANSI，而中国地区是gbk    
   # 1. 内存中，联通这两个字是用gbk进行编码的，      c1aa cda8->
   # 2. 保存时，保存的是将gbk的二进制位                         1100 0001 1010 1010 1100 1101 1010 1000
   # 3. 从硬盘中读取时，由于储存的联通的gbk编码符合utf-8的编码方式，读取时的解码方式为utf-8         
   # 4. 解码时将gbk编码当成utf-8编码，使得解码时，按照utf-8来解码成unicode                            
   #unicode				UTF-8
   #0000-007F				0xxxxxxx
   #0080-07FF				110xxxxx 10xxxxxx	
   #0800-FFFF				1110xxxx 10xxxxxx 10xxxxxx
   #
   #    ：11000001 10101010 11001101 10101000                                                    :
   #    ->00001 101010 01101 101000                去除utf-8的默认前缀
   #    ->0000 0000 0110 1010 0000 0011 0110 1000         补上零，补足两字节
   #    0000 0000 0110 1010->006a     unicode编码：006a->j
   #    0000 0011 0110 1000->0368     0000 0011 0110 1000不存在
   ~~~

   



