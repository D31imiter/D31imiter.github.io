### 进程调度

进程调度所追求的是性能与公平

T 周转时间 = T 完成时间−T 到达时间

T 响应时间 = T 首次运行−T 到达时间

#### 假设

我们先对操作系统中的进程做出如下的假设：

1．每一个工作运行相同的时间
2．所有的工作同时到达
3．一旦开始，每个工作保持运行直到完成
4．所有的工作只是用 CPU（即它们不执行 IO 操作）
5．每个工作的运行时间是已知的

#### FIFO（First In First Out）|  FCFS（First Come First Served）

先进先出调度，有时候也称为先到先服务，但是FIFO会引发护航效应，一些耗时较少的潜在资源消费者被排在重量级的资源消费者之后。

#### SJF（Shortest Job First）

最短任务优先，这种调度方式可以解决护航问题，但如果任务到达的时间不一致，重量级的资源消费者先到达，同样会引发护航效应。

#### STCF（Shortest Time-to-Completion First）|  PSJF（Preemptive Shortest Job First）

最短完成时间优先或抢占式最短作业优先，每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作。STCF虽然有很好的周转时间，但对于响应时间和交互性是相当糟糕的。假设你在终端前输入，因为其他一些工作已经在输入之前被调度，你不得不等待之后才能看到系统的回应

#### RR（Round-Robin）

轮转，在一个时间片（time slice，有时间称调度量子，scheduling quantum）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成。注意，时间片长度必须是时钟中断周期的倍数。

时间片太短会导致频繁的上下文切换，将影响整体性能。因此需要权衡时间片的长度，使其足够长，以便摊销（amortize）上下文切换成本，而又不会使系统不及时响应。

如果响应时间是我们的唯一指标，那么带有合理时间片的 RR，就会是非常好的调度程序。如果周转时间是我们的指标，那么 RR 确实是最糟糕的策略之一。任何公平的政策（即在小规模的时间内将 CPU 均匀分配到活动进程之间），在周转时间这类指标上表现不佳。事实上，这是固有的权衡：如果你愿意不公平，你可以运行较短的工作直到完成，但是要以响应时间为代价。如果你重视公平性，则响应时间会较短，但会以周转时间为代价。
