1. xss漏洞说一下：

   ```
   xss漏洞是Cross Site Scripting，跨站请求脚本，是一种HTML注入攻击，服务端没有对客户端输入的内容做过滤导致来自恶意用户构造的的js脚本被嵌入到HTML页面中，分为反射型，储存型，DOM型等，反射型XSS常被用做钓鱼邮件等，其中储存型危害较大，多出现在论坛，聊天室等，用户一旦加载，浏览器就解析恶意的js代码，DOM型XSS就是恶意的客户可以在有漏洞的网站嵌入恶意JS代码，改变HTLM DOM树结构，普通客户一旦访问就变成了受害者。
   xss的漏洞的后续利用基本上依赖于XSS箱子，网上有别人开发好的网站提供这种对XSS漏洞后续利用的服务，但利用时自身也可能成为受害者，常用的xss权限维持工具有BEef，旧版本Kali自带，集成了许多攻击模块，Get All Cookie模块盗取用户的Cookie，配合CSRF组合进行下一步利用，例如利用盗取的Cookie登录管理员后台。
   ```
2. SQL注入说一下：

   ```
   SQL注入漏洞成因是将未做严格过滤用户输入的参数拼接到SQL语句中执行，恶意用户经过构造输入特定的的Payload即可造成任意SQL语句的执行，在secure_file_priv选项开启时还会使攻击者获取任意读写文件的权限，再者，如果是以root权限登录的数据库，对应特定的数据库，攻击者还可能利用mysql的UDF提权，oracle自定义java提权函数，Access数据库溢出提权，直接获取更高权限。
   SQL注入的利用主要从两方面来看，构造利用，获取回显；原SQL语句执行的功能不同可能会造成Payload的不同，查询的字段为char或varchar，就考虑到查询时对字符串引用了单引号和双引号，或有无括号，当编码为GBK时可以考虑宽字节绕过；从回显的角度来看，如果对方直接将查询的结果返回给前端页面，那就用最普通的联合查询，或者服务端可能将查询到的数据返回到Cookie或其他返回数据包的字段，如果没有返回，尝试利用盲注，盲注又分为时间盲注，布尔盲注，报错盲注。
   绕过方式：
   1. 大小写
   2. 多重关键字，双拼写
   3. 编码绕过，在php默认编码和转义函数配合失误时可以使用
   4. 使用注释符绕过
   5. 使用等价的函数或命令
   等价函数形式：Mysql查询：Union distinct、updatexml、Extractvalue、floor
   字符串截取函数：mid、substr、substring、left、reverse
   字符串连接函数：concat、group_concat、concat_ws
   字符串转换：char、hex、unhex
   替换逗号：limit 1 offset 0，mid(version() from 1 for 1)
   替换等号：like
   ```
3. 文件包含的危害：

   ```
   未对用户输入的参数做严格过滤，攻击者利用../来读取任意路径下的文件，或是利用php伪协议，filter读取任意文件，input或data协议写入任意文件，攻击者甚至可以利用请求头，将一句话木马写入/var/log/apache2/access_log，再次对日志文件包含，导致一句话木马被解析，从而获取shell
   ```
4. SSRF说一下：

   ```
   SSRF是服务器端请求伪造漏洞，服务端没有对用户端输入的数据进行过滤就放到危险函数中执行， 攻击者通过利用SSRF能扫描内部网络，获取端口，服务信息，攻击运行在内网或本地的应用程序，对内网web进行指纹识别，对内部主机和端口发送请求包进行攻击，协议读取本地文件。
   例如配合其他注入漏洞实现反弹shell，攻击Redis
   ```
5. Shiro反序列化说与一下：

   ```
   Shiro框架开发的应用程序，在用户登录时有一个rememberMe的选项，勾选后，用户登录会发送rememberMe的一个键值对，服务端会将rememberMe的值base64解码，AES解密后反序列化（由于AES密钥是默认是固定的，如果开发者未修改默认密钥，攻击者即可构造任意的数据发送给服务端），具体的攻击过程是服务端将客户端传过来的rememberMe值发送给getRememberedPrincipals函数，Base64解码后利用函数convertBytesToPrincipals再次AES解密，在这个函数的返回处又调用了一个deserialize方法，这个原生的反序列化方法中又把参数传给了readobject方法，之后再利用对cc链的攻击或shiro自带的依赖的beanutils的攻击，即可执行任意代码
   ```
6. JNDI注入说一下：

   ```
   Java Naming and Directory Interface,java命名和目录接口，相当于将一个服务名称和一个对象绑定，开发者在开发过程中可以使用名称来访问对象。JNDI由三部分组成：JNDI API、Naming Manager、JNDI SPI。JNDI API是应用程序调用的接口，JNDI SPI是具体实现，应用程序需要指定具体实现的SPI。JNDI服务管理着一堆的名称和这些名称上绑定着的对象。如果这些对象不是本地的对象，JNDI服务从指定的远程服务器上下载class文件，加载到本地JVM中，并通过适当的方式创建对象。
   ```
7. fastjson反序列化说一下：

   ```
   由于引进了AutoType功能，fastjson在对json字符串反序列化的时候，会读取到@type的内容，将json内容反序列化为java对象并调用这个类的setter方法。使用AutoType功能进行序列号的JSON字符会带有一个@type来标记其字符的原始类型，在反序列化的时候会读取这个@type，来试图把JSON内容反序列化到对象，并且会调用这个库的setter或者getter方法，然而，@type的类有可能被恶意构造，只需要合理构造一个JSON，使用@type指定一个想要的攻击类库就可以实现攻击。sun官方提供的一个类com.sun.rowset.JdbcRowSetImpl，其中有个dataSourceName方法支持传入一个rmi的源，只要解析其中的url就会支持远程调用对fastjson的利用依赖于RMI，当攻击者添加com.sun.rowset.JdbcRowSetImpl恶意类信息发送给目标机器，目标服务器去请求RMI服务器，RMI服务器又去远程请求远程机器class，我们将编译好的.class文件上传到恶意站点，RMI服务器返回恶意指令给目标机器，目标机器执行恶意代码，被攻击者利用。
   ```
8. JBOSS反序列化说一下：

   ```
   该漏洞位于JBoss的HttpInvoker组件中的 ReadOnlyAccessFilter 过滤器中，其doFilter方法在没有进行任何安全检查和限制的情况下尝试将来自客户端的序列化数据流进行反序列化。
   ```
9. weblogic反序列化说一下：

   ```
   1.直接通过T3协议发送恶意反序列化对象(CVE-2015-4582、CVE-2016-0638、CVE-2016-3510、CVE-2020-2555、CVE-2020-2883)
   2.利用T3协议配合RMP或ND接口反向发送反序列化数据(CVE2017-3248、CVE2018-2628、CVE2018-2893、CVE2018-3245、CVE-2018-3191、CVE-2020-14644、CVE-2020-14645)还有利用IIOP协议的CVE-2020-2551
   3.通过 javabean XML方式发送反序列化数据。(CVE2017-3506->CVE-2017-10271->CVE2019-2725->CVE-2019-2729)
   ```
10. Linux应急响应：

    ```
    1. 查看三个用户文件有无变更，个用户历史命令记录
    2. 查看登录日志，在/var/log/secure，last命令查看登录历史
    3. netstat -pantu查看开放端口，crontab -l 查看计划任务，ps -aux 查看进程，systemctl list-unit-files | grep enabled查看自启项
    4. 查看后门文件，分析tmp目录和网站目录
    ```
11. windows应急响应：

    ```
    1. 直接启用管理员权限查看注册表
    2. eventvwr->windows日志->安全,查看事件
    3. netstat -ano 查看开放端口查看开放的端口，schtasks 查看计划任务，tasklist 查看进程，taskkill /PID值终止进程
    4. 查看后门文件，%temp%文件夹下和网站目录下
    ```
12. 后门软件流量特征：

    * 哥斯拉流量特征

      ```
      User-Agent,默认情况下如果不修改为Java/1.8.0_121，如果修改此特征容易被抹除
      Cookie最后的分号。标准的HTTP请求中最后一个Cookie的值是不应该出现;的，可以作为辅助识别特征
      斯拉支持对加密的数据进行base64编码以及原始的加密raw两种形式的通讯数据，进行初始化时会产生一个比较大的数据包，后面进行命令执行等操作时产生的base64数据包会比较比较小
      从代码可以看到会把一个32位的md5字符串按照一半拆分，分别放在base64编码的数据的前后两部分。整个响应包的结构体征为：md5前十六位+base64+md5后十六位。
      正则匹配：（?i:[0-9A-F]{16})[\w+/]{4,}=?=?(?i:[0-9A-F]{16})
      需要注意的是md5需要同时匹配字母大小写两种情况，因为在JAVA版webshell响应中为大写字母，在PHP版中为小写字母。
      ```
    * 冰蝎流量特征

      ```
      Accept,可能为application/json 和 text/javascript
      Content-type: Application/x-www-form-urlencoded可以作为辅助识别特征
      冰蝎与webshell建立连接的同时，javaw也与目的主机建立tcp连接，每次连接使用本地端口在49700左右(就是比较大的端口)，每连接一次，每建立一次新的连接，端口就依次增加，可以对符合该范围内的端口告警
      冰蝎通讯默认使用长连接，避免了频繁的握手造成的资源开销。默认情况下，请求头和响应头里会带有 Connection
      默认连接密码rebeyond，所有冰蝎4.0 webshell都有e45e329feb5d925b 一串密钥，该密钥为连接密码32位md5值的前16位
      ```
    * 蚁剑流量特征

      ```
      明文@ini_set("display_errors","0");
      ```
13. LDAP注入说一下

    ```
    Lightweight Directory Access Protocol,轻量级目录访问协议，默认的端口是 389，加密的端口是 636。LDAP有特定的查询语法，来对特定目录进行遍历。攻击者利用用户引入的参数生成LDAP查询，由于部分参数没有适当的过滤，因此攻击者可以注入恶意代码以造成恶意攻击。
    ```
14. 安全日志：

    ```
    Linux登录日志，last命令，/var/log/wtmp文件
    Windows登录日志，输入eventvwr，在安全中查看

    登录类型2：交互式登录（Interactive）,交互式登录就是指用户在计算机的控制台上进行的登录，也就是在本地键盘上进行的登录

    登录类型3：网络（Network）,通过网络的上访问一台计算机时在大多数情况下Windows会记为类型3，最常见的情况就是连接到共享文件夹或者共享打印机

    登录类型4: 批处理（Batch）,当Windows运行一个计划任务时，“计划任务服务”将为这个任务首先创建一个新的登录会话以便它能在此计划任务所配置的用户账户下运行，当这种登录出现时，Windows在日志中记为类型4，对于其它类型的工作任务系统，依赖于它的设计，也可以在开始工作时产生类型4的登录事件，类型4登录通常表明某计划任务启动，但也可能是一个恶意用户通过计划任务来猜测用户密码，这种尝试将产生一个类型4的登录失败事件，但是这种失败登录也可能是由于计划任务的用户密码没能同步更改造成的，比如用户密码更改了，而忘记了在计划任务中进行更改

    登录类型5：服务（Service）,与计划任务类似，每个服务都被配置在某个特定的用户账户下运行，当一个服务开始时，Windows首先为这个特定的用户创建一个登录会话，这将被记为类型5，失败的类型5通常表明用户的密码已变而这里没得到更新，当然这也可能是由恶意用户的密码猜测引起的，但是这种可能性比较小，因为创建一个新的服务或编辑一个已存在的服务默认情况下都要求是管理员或服务器管理员身份，而这种身份的恶意用户，已经有足够的能力来干他的坏事了，已经用不着费力来猜测服务密码了

    登录类型7：解锁（Unlock）,你可能希望当一个用户离开他的计算机时相应的工作站自动开始一个密码保护的屏保，当一个用户回来解锁时，Windows就把这种解锁操作认为是一个类型7的登录，失败的类型7登录表明有人输入了错误的密码或者有人在尝试解锁计算机


    登录类型10：远程交互（RemoteInteractive）,当你通过终端服务、远程桌面或远程协助访问计算机时，Windows将记为类型10，以便与真正的控制台登录相区别，注意XP之前的版本不支持这种登录类型，比如Windows2000仍然会把终端服务登录记为类型2

    登录类型11：缓存交互（CachedInteractive）,Windows支持一种称为缓存登录的功能，这种功能对移动用户尤其有利，比如你在自己网络之外以域用户登录而无法登录域控制器时就将使用这种功能，默认情况下，Windows缓存了最近10次交互式域登录的凭证HASH，如果以后当你以一个域用户登录而又没有域控制器可用时，Windows将使用这些HASH来验证你的身份


    Apache日志，在/var/log/Apache/access_log查看
    日志分析
    ```
15. Java内存马：

    ```
    Java网站会有一个web容器，listener，filter，servlet都是在web.xml中配置的，三者都是一个java类。
    listener监听Application、Session和Request三大对象创建或者删除，然后根据监听的结果来执行提前编写的代码。
    filter接收来自客户端的web请求并对其进行必要的修改和内容判断。如果没有filter存在，那么请求将会直接发给servlet。可以个servlet在web.xml中配置多个filter。当 Servlet 容器开始调用某个Servlet程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用servlet 的service 方法，而是调用Filter的doFilter方法，再由doFilter方法决定是否去激活service方法。
    servlet由容器进行调度和执行，是处理数据的模块。里面有一个函数services，这个函数是servlet的核心代码，实现servlet的核心功能。
    内存马即，将木马实现写入某个filter的dofilter方法中，将url与某个filter绑定，访问某个url触发dofilter方法

    对java内存马查杀：
    1.如果是jsp注入，日志中排查可以jsp的访问请求
    2.如果是代码执行漏洞，排查中间件的error.log,查看是否有可疑的报错，判断注入时间和方法
    3.借助于Java-Agent技术
    4. 其他师傅写的内存马检测工具
    Arthas，SA-JDI
    ```
16. 文件上传说一下：

    ```
    对上传的文件不做限制或限制不够，导致木马被上传到网站目录下，服务端收到http请求后端解析木马脚本。
    一些常见的后缀：
    当对方网站为IIS服务器时，可以上传asp，aspx文件，Iis服务器开启了文件后缀扩展功能（扩展名映射），可以使用asa或者cdx或者cer尝试进行上传
    对方网站开发语言为php的时候，可以使用php5，php7，phtml等后缀绕过
    绕过总结：
    1. 模糊测试
    2. 黑名单绕过，使用别的可执行后缀
    3. 在后缀名后加". "，windows会自动将". "删除
    4. 有时用户可以上传配置文件，将原文件覆盖，就可以轻松绕过各种检测
    5. 配合其中间件的解析漏洞来绕过
    ```
17. Springboot框架漏洞
18. redis未授权访问漏洞

    ```
    在保护模式为开启的情况下才有可能利用
    1. redis-cli -h [ip] 远程连接redis
    2. info查看一些服务信息
    3. config get dir|dbfilename 获取默认的目录以及rdb文件名，最后复原
    4. config set dir [path] 决定写入文件的路径
    5. config set dbfilename [filename] 决定写入的文件名
    6. set key value 来确定文件的内容，key值任意即可，value即为文件内容
    7. 使用save命令来确定以上所有操作并生成文件
    三种利用，写webshell，公钥，php反弹shell

    防护
    1. 开启保护模式
    2. 以低权限运行redis
    3. 添加验证密码
    4. 禁止外网访问redis
    ```
19. 被0day打了怎么办

    ```
    0day会产生较多告警
    ```
20. 应急响应

    ```
    1. 首先隔离失陷主机，避免攻击队进一步的横向移动和扣分，先填写，其次排查留下的后门，通过查注册表，有无新增用户，定时任务，有无落地的webshell，有无内存马，先查杀后门
    2. 再即时像设备中添加告警规则，再去分析漏洞的成因，对方是怎么打进来的，看告设备的告警信息，分析数据包，找到漏洞成因，在修复前取得客户同意可以关闭一部分服务的功能，修复后再上线
    3. 修复漏洞，将利用方式排查完后锁定攻击者的身份，例如在沙箱中分析，情报平台查恶意服务器，进行溯源，然后写总结报告
    ```
21. logj4

    ```
    一个java日志工具，其中一个lookup接口提供了解析功能，在${}中的内容会被解析，如果利用jndi协议，指向远程的RMI服务或者LDAP服务来解析，就会引发安全题，例如远程加载RMI对象，导致执行这个类的静态代码块中的内容，造成RCE
    ```
22. 你用过什么设备

    ```
    参加过天融信和奇安信的项目，在山西移动时使用过天融信的僵木蠕，在北京人社局时使用过天眼，椒图，天擎
    ```
23. 如何判断一个攻击是否为误报

    ```
    先看攻击ip属于内网还是外网，如果属于内网ip，多半是运维人员的操作引起的误报，也可以跟据其告警发生的时间，如果是hw前就开始的长期连续的告警，在大概率为误报，如果是外网ip，从请求数据包来分析
    ```
