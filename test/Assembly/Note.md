# Assembly

#### 指令

1. lea: load effective address
   lea	eax,[address]
   直接将地址复制到寄存器
2. db：（define byte）定义字节
   dw：（define word）定义字类型，两个字节
   dd：（define double  word）定义双字类型变量
   dup：伪指令，用来重负定义变量
3. movsb以字节为单位进行移动
   movsw以字为单位进行移动
   movsd以双字为单位进行移动
   三者都是相当于 mov [di],[si],
4. rep 汇编指令：相当于循环cx次汇编指令
5. and
   xor op1，op2
   按位且
6. or
   or op1，op2
   按位或
7. xor
   xor op1，op2
   按位异或
8. not op
   取op的反码赋值给op
9. add：add   op1,op2
   op1+=op2
10. sub：sub   op1,op2
    op1-=op2
11. inc：inc    op
    op++
12. dec：dec	 op
    op--
13. push 寄存器/段寄存器/内存单元：将寄存器/段寄存器/内存单元的数值压入栈，sp减小
    pop 寄存器/段寄存器/内存单元：将在栈顶元素弹出赋值给寄存器/段寄存器/内存单元，sp++
14. adc：进位加法指令，利用了CF位上记录的进位值
    adc op1,op2
    op1=op1+op2+CF
15. sbb：借位减法指令，利用了CF位上记录的进位值
    adc op1,op2
    op1=op1-op2-CF
16. mul AX,8位操作数：结果存放在AX
    mul AX,16位操作数：低位放在AX，高位放在DX
    mul EAX，32位操作数：低位放在EAX，高位放在EDX
17. cmp：通过对标志寄存器产生影响得到反馈，相当于减法指令生成但不保存结果
    cmp op1,op2
    相同时：ZF=1，PF=1，SF=0，CF=0，OF=0
    不同时：ZF=0，
18. offset：操作符，伪指令，由编译器处理，获取标号的偏移地址
19. jmp：jmp指令通过偏移量来跳转，记标号处相对当前指令的偏移量disp，nop指令
    1. jmp 标号，jmp short 标号，jmp near ptr 标号，jmp far ptr 标号
       1. 向前跳转：
          1. disp[-128,127]:指令全部转为jmp short s的机器码
          2. disp[-32768,32767]:jmp short s编译错误，jmp far ptr s将生成EA disp，其他指令生成E9 disp
       2. 向后跳转：nop指令即预留1个字节的空间用来存放disp
          1. disp[-128,127]:jmp far ptr s将生成对应的机器码以及三条nop指令，其他指令全部转为jmp short s的机器码以及1条nop指令
          2. disp[-32768,32767]:jmp short s编译错误，jmp far ptr s将生成对应的机器码以及三条nop指令，其他指令全部转为jmp short s的机器码以及1条nop指令
    2. jmp 寄存器：16位寄存器赋值给IP，实现段内的近(短)转移
    3. jmp cs:ip  ：同时修改cs，ip，实现短转移和近转移
20. 条件跳转：je，jne，jb，jnb，ja，jna
    通过比较标记寄存器来决定是否跳转
21. pushf：将标志寄存器的值压入栈
    popf：弹出栈顶的值赋给标志寄存器
22. iret：相当于：pop IP    pop CS    popf
23. shl：逻辑左移，将一个寄存器或内存单元中的数据向左移位，将最后移出的一位写入CF中，最低位用0补充，如果移动位数大于1时，必须将移动位数放在cl中
    shr：逻辑右移，将一个寄存器或内存单元中的数据向右移位，将最后移出的一位写入CF中，最高位用0补充，如果移动位数大于1时，必须将移动位数放在cl中
24. 

* movsw以字为单位进行移动
* movsw以字为单位进行移动
* movsw以字为单位进行移动
* movsd以双字为单位进行移动
* movsd以双字为单位进行移动
* movsd以双字为单位进行移动
* movsw以字为单位进行移动
* movsb以字节为单位进行移动
* movsd以双字为单位进行移动
* movsw以字为单位进行移动
* movsb以字节为单位进行移动
* movsd以双字为单位进行移动
* movsw以字为单位进行移动
* movsb以字节为单位进行移动




##### x64指令补充

## Debug

1. **-t ：执行当前指令**
2. **-r AX：修改寄存器的值**
3. **-d 段基址:偏移地址：查看机器码**
4. **-u 段基址:偏移地址：将机器码翻译成汇编指令**
5. **-a：将汇编指令写入内存**

## 定义数据类型

DB定义的为字节类型，DW定义字类型，DD定义双字类型,DF为长字类型,DQ为四字类型,DT为十字节类型,该指令分别定义8位,16位,32位,48位,64位,80位的数据

## 寄存器

1. AX（Accumulator）：通用寄存器，累加器
2. BX（Base Register）：**基地址寄存器**，[BX]，取bx寄存器中数据的值作为偏移地址
3. CX（Count Register）：循环时CX-=1，为CX为0时跳出循环，计数器
4. DX（Data Register）：数据寄存器，存放数据
5. DS：数据段基址
6. CS：代码段基址
7. SS：栈段基址
8. ES：附加段基址
9. IP（Instruction Pointer）：指令指针寄存器，指示要执行指令所在存储单元的地址。IP寄存器是一个专用寄存器
10. sp（Stack Pointer）：表示栈顶指针,指向栈顶地址
11. bp（Base Pointer）：是基址指针,段地址默认在SS中，表示堆栈区域中的基地址
12. DI（Destination Index）：目的变址寄存器，一般情况下与ds联用,来确定某个储存单元的地址.
13. SI（Source Index）：源变址寄存器，默认段地址和DI一样，在DS中和DS联用
14. ### 标志寄存器

    8086cpu标志寄存器仅有16位，其中存储的信息通常被称为程序状态字（PSW）

    | 15    | 14 | 13 | 12 | 11 | 10 | 9  | 8  | 7  | 6  | 5 | 4  | 3 | 2  | 1 | 0  |
    | ----- | -- | -- | -- | -- | -- | -- | -- | -- | -- | - | -- | - | -- | - | -- |
    |       |    |    |    | OF | DF | IF | TF | SF | ZF |   | AF |   | PF |   | CF |
    | TURE  | 1  |    |    | OV | DN | EI |    | NG | ZR |   | AC |   | PE |   | CY |
    | FALSE | 0  |    |    | NV | UP | DI |    | PL | NZ |   | NA |   | PO |   | NC |


    1. ZF：零标志位(Zero flag)，上一条指令执行得结果为0，则ZF为1
    2. PF：奇偶标志位(Parity flag)，记录执行结果后二进制位中的1的个数，为偶数则PF为1
    3. SF：符号标志位(Sign flag)，记录执行结果后，负数为1，正数为0
    4. CF：进位标志位(Carry flag)，对于无符号数而言，运算时记录了最高有效位向更高位的进位制或者借位值
    5. OF：溢出标志位(Over flow flag)对于有符号数而言，运算时记录是否产生了溢出
    6. IF：中断标志位(Interrupt flag)，是否中断
    7. TF：陷阱标志位(Trap flag),CPU执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断引发中断过程
    8. AF：辅助标志位(Auxiliary carry flag)

## 段

1. 数据段：通过dd，dw，db，dup等伪指令存放数据，ds寄存器存放当前数据段的段基址
2. 代码段：ds寄存器存放当前代码段的段基址，ip寄存器存放下一条将要执行的指令相对当前代码段的段基址的偏移量
3. 栈段：ss寄存器存放当前栈段的段基址，栈顶为低地址，栈底为高地址，push时栈顶指针寄存器sp减小，pop时栈顶指针寄存器sp增加
4. 附加段：储存数据

## 中断

### 类型

中断分为软件中断和硬件中断

软件中断：软件中断并不是真正的中断，是被调用执行的一般程序以及DOS系统功能调用（int 21）

硬件中断：分为内中断和外中断

1. 内部中断：硬件出错（掉电），运算出错（出书为0，单步中断）等，无法屏蔽
2. 外部中断：计算机以外的设备发出中断请求，如键盘中断、打印机中断、定时器中断等外部中断是可以屏蔽的中断，利用中断控制器可以屏蔽这些请求

中断的优先级：

1. 除法出错，溢出中断，软件中断
2. 不可屏蔽中断
3. 可屏蔽中断
4. 单步中断

中断信息包含有标识中断源的类型码，根据cpu的设计，中断源类型码的作用就是用来定位中断处理程序

### 中断向量列表：

中断向量（中断处理程序的入口地址）的列表，在内存中保存，存放着256个中断源所对应的中断处理程序入口，向量表放在内存地址0处，从内存0000:0000到0000:03FF的1024(一个物理地址是由段地址和偏移地址构成，要用4个字节来存放)个单元中存放着中断向量表。cpu用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址，中断向量表中存放的就是各个类型的处理程序的地址，8位的类型码是个索引。

### 中断过程

1. 从中断信息中取得中断类型码
2. 标志寄存器的值入栈，以保护标志位
3. 设置标志寄存器的第8位TF和第9位IF的值为0
4. CS的内容入栈，IP的内容入栈
5. 设置ip为：中断类型码* 4，设置cs为：中断类型码 *4+2的两个字单元
6. CPU开始执行由程序员编写的中断处理程序

### 相应中断的特殊情况

在执行完向ss寄存器传送数据的指令后，即便检测到了中断信号CPU也不会响应，因为ss:sp指向栈顶，两者应连续变化，如果CPU响应中断引发中断过程，在栈中压入了标志寄存器，CS，IP的值，将引发错误，没有意义

### 内中断：

| 中断信息             | 中断类型码 |
| -------------------- | ---------- |
| 除法错误             | 0          |
| 单步执行             | 1          |
| 执行into指令         | 4          |
| 执行int指令（int n） | n          |

### 外中断：

1. 可屏蔽中断，cpu可以不响应的外中断，是否屏蔽取决与IF的设置
   IF=1执行完当前指令响应中断，IF=0不响应中断
2. 不可屏蔽中断

## PLT与GOT

1. PLT：procedure linkage table，过程连接表，位于代码段，是一个每个条目是16字节内容的数组。其中PLT[0]储存的信息能用来跳转到动态链接器中，PLT[1]是系统启动函数（__libc_start_main）,其余每个条目都负责调用一个具体的函数。
2. GOT：Globle offset table全局偏移量表，位于数据段，是一个每个条目是8字节地址的数组，用来存储外部函数在内存的确切地址，GOT表存储在数据段，可以在程序运行中被修改。
